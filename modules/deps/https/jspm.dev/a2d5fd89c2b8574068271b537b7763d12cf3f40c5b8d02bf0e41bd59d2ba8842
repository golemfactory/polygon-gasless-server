import _buffer from '/npm:buffer@5!cjs';
import _baseX from '/npm:base-x@3!cjs';

var exports = {};

class Base {
  constructor(name, code, implementation, alphabet) {
    this.name = name;
    this.code = code;
    this.alphabet = alphabet;

    if (implementation && alphabet) {
      this.engine = implementation(alphabet);
    }
  }

  encode(stringOrBuffer) {
    return this.engine.encode(stringOrBuffer);
  }

  decode(stringOrBuffer) {
    return this.engine.decode(stringOrBuffer);
  }

  isImplemented() {
    return this.engine;
  }

}

exports = Base;
var _base = exports;

var exports$1 = {};
const {
  Buffer
} = _buffer;

exports$1 = function base16(alphabet) {
  return {
    encode(input) {
      if (typeof input === "string") {
        return Buffer.from(input).toString("hex");
      }

      return input.toString("hex");
    },

    decode(input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error("invalid base16 character");
        }
      }

      return Buffer.from(input, "hex");
    }

  };
};

var _base2 = exports$1;

var exports$2 = {};

function decode(input, alphabet) {
  input = input.replace(new RegExp("=", "g"), "");
  const length = input.length;
  let bits = 0;
  let value = 0;
  let index = 0;
  const output = new Uint8Array(length * 5 / 8 | 0);

  for (let i = 0; i < length; i++) {
    value = value << 5 | alphabet.indexOf(input[i]);
    bits += 5;

    if (bits >= 8) {
      output[index++] = value >>> bits - 8 & 255;
      bits -= 8;
    }
  }

  return output.buffer;
}

function encode(buffer, alphabet) {
  const length = buffer.byteLength;
  const view = new Uint8Array(buffer);
  const padding = alphabet.indexOf("=") === alphabet.length - 1;

  if (padding) {
    alphabet = alphabet.substring(0, alphabet.length - 1);
  }

  let bits = 0;
  let value = 0;
  let output = "";

  for (let i = 0; i < length; i++) {
    value = value << 8 | view[i];
    bits += 8;

    while (bits >= 5) {
      output += alphabet[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }

  if (bits > 0) {
    output += alphabet[value << 5 - bits & 31];
  }

  if (padding) {
    while (output.length % 8 !== 0) {
      output += "=";
    }
  }

  return output;
}

exports$2 = function base32(alphabet) {
  return {
    encode(input) {
      if (typeof input === "string") {
        return encode(Uint8Array.from(input), alphabet);
      }

      return encode(input, alphabet);
    },

    decode(input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error("invalid base32 character");
        }
      }

      return decode(input, alphabet);
    }

  };
};

var _base3 = exports$2;

var exports$3 = {};
const {
  Buffer: Buffer$1
} = _buffer;

exports$3 = function base64(alphabet) {
  // The alphabet is only used to know:
  //   1. If padding is enabled (must contain '=')
  //   2. If the output must be url-safe (must contain '-' and '_')
  //   3. If the input of the output function is valid
  // The alphabets from RFC 4648 are always used.
  const padding = alphabet.indexOf("=") > -1;
  const url = alphabet.indexOf("-") > -1 && alphabet.indexOf("_") > -1;
  return {
    encode(input) {
      let output = "";

      if (typeof input === "string") {
        output = Buffer$1.from(input).toString("base64");
      } else {
        output = input.toString("base64");
      }

      if (url) {
        output = output.replace(/\+/g, "-").replace(/\//g, "_");
      }

      const pad = output.indexOf("=");

      if (pad > 0 && !padding) {
        output = output.substring(0, pad);
      }

      return output;
    },

    decode(input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error("invalid base64 character");
        }
      }

      return Buffer$1.from(input, "base64");
    }

  };
};

var _base4 = exports$3;

var exports$4 = {};
const Base$1 = _base;
const baseX = _baseX;
const base16 = _base2;
const base32 = _base3;
const base64 = _base4; // name, code, implementation, alphabet

const constants = [["base1", "1", "", "1"], ["base2", "0", baseX, "01"], ["base8", "7", baseX, "01234567"], ["base10", "9", baseX, "0123456789"], ["base16", "f", base16, "0123456789abcdef"], ["base32", "b", base32, "abcdefghijklmnopqrstuvwxyz234567"], ["base32pad", "c", base32, "abcdefghijklmnopqrstuvwxyz234567="], ["base32hex", "v", base32, "0123456789abcdefghijklmnopqrstuv"], ["base32hexpad", "t", base32, "0123456789abcdefghijklmnopqrstuv="], ["base32z", "h", base32, "ybndrfg8ejkmcpqxot1uwisza345h769"], ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"], ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"], ["base64", "m", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"], ["base64pad", "M", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="], ["base64url", "u", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"], ["base64urlpad", "U", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]];
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base$1(tupple[0], tupple[1], tupple[2], tupple[3]);
  return prev;
}, {});
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]];
  return prev;
}, {});
exports$4 = {
  names: names,
  codes: codes
};
var _constants = exports$4;
const _names = exports$4.names,
      _codes = exports$4.codes;

export default _constants;
export { _codes as codes, _names as names };

//# sourceMappingURL=constants!cjs.map