import assert from '../npm:@noble/hashes@1.3.1/_assert';
import { hexToBytes as hexToBytes$1 } from '../npm:@noble/hashes@1.3.1/utils';
export { bytesToHex, concatBytes, createView, bytesToHex as toHex, utf8ToBytes } from '../npm:@noble/hashes@1.3.1/utils';

const assertBool = assert.bool;
const assertBytes = assert.bytes;
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return hexToBytes$1(sliced);
}
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        assert.bytes(msg);
        return hash(msg);
    };
}
// TODO(v3): switch away from node crypto, remove this unnecessary variable.
const crypto = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

export { assertBool, assertBytes, bytesToUtf8, crypto, equalsBytes, hexToBytes, wrapHash };

//# sourceMappingURL=utils.map