import '/npm:minimalistic-assert@1!cjs';
import '/npm:inherits@2!cjs';
import { e as exports$1, a as exports$2 } from '../../../_/d70f5bf3.js';
import { e as exports$3 } from '../../../_/1e588aae.js';

var exports = {};
var utils = exports$1;
var common = exports$2;
var shaCommon = exports$3;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];

function SHA1() {
  if (!(this instanceof SHA1)) return new SHA1();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) W[i] = msg[start + i];

  for (; i < W.length; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === "hex") return utils.toHex32(this.h, "big");else return utils.split32(this.h, "big");
};

var _ = exports;

export default _;

//# sourceMappingURL=1!cjs.map