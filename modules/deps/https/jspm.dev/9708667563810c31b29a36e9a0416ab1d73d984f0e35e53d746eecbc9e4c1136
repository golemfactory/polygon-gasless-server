import * as _bn2 from './npm:bn.js@5!cjs';
import _buffer from './npm:@jspm/core@2/nodelibs/buffer';

var _bn = "default" in _bn2 ? _bn2.default : _bn2;
var exports = {};
var Buffer = _buffer.Buffer;

var __importDefault = exports && exports.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLength = exports.decode = exports.encode = void 0;

var bn_js_1 = __importDefault(_bn);
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/


function encode(input) {
  if (Array.isArray(input)) {
    var output = [];

    for (var i = 0; i < input.length; i++) {
      output.push(encode(input[i]));
    }

    var buf = Buffer.concat(output);
    return Buffer.concat([encodeLength(buf.length, 192), buf]);
  } else {
    var inputBuf = toBuffer(input);
    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
  }
}

exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */

function safeParseInt(v, base) {
  if (v[0] === "0" && v[1] === "0") {
    throw new Error("invalid RLP: extra zeros");
  }

  return parseInt(v, base);
}

function encodeLength(len, offset) {
  if (len < 56) {
    return Buffer.from([len + offset]);
  } else {
    var hexLength = intToHex(len);
    var lLength = hexLength.length / 2;
    var firstByte = intToHex(offset + 55 + lLength);
    return Buffer.from(firstByte + hexLength, "hex");
  }
}

function decode(input, stream) {
  if (stream === void 0) {
    stream = false;
  }

  if (!input || input.length === 0) {
    return Buffer.from([]);
  }

  var inputBuffer = toBuffer(input);

  var decoded = _decode(inputBuffer);

  if (stream) {
    return decoded;
  }

  if (decoded.remainder.length !== 0) {
    throw new Error("invalid remainder");
  }

  return decoded.data;
}

exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */

function getLength(input) {
  if (!input || input.length === 0) {
    return Buffer.from([]);
  }

  var inputBuffer = toBuffer(input);
  var firstByte = inputBuffer[0];

  if (firstByte <= 127) {
    return inputBuffer.length;
  } else if (firstByte <= 183) {
    return firstByte - 127;
  } else if (firstByte <= 191) {
    return firstByte - 182;
  } else if (firstByte <= 247) {
    // a list between  0-55 bytes long
    return firstByte - 191;
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 246;
    var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
    return llength + length_1;
  }
}

exports.getLength = getLength;
/** Decode an input with RLP */

function _decode(input) {
  var length, llength, data, innerRemainder, d;
  var decoded = [];
  var firstByte = input[0];

  if (firstByte <= 127) {
    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    };
  } else if (firstByte <= 183) {
    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
    // The range of the first byte is [0x80, 0xb7]
    length = firstByte - 127; // set 0x80 null to 0

    if (firstByte === 128) {
      data = Buffer.from([]);
    } else {
      data = input.slice(1, length);
    }

    if (length === 2 && data[0] < 128) {
      throw new Error("invalid rlp encoding: byte must be less 0x80");
    }

    return {
      data: data,
      remainder: input.slice(length)
    };
  } else if (firstByte <= 191) {
    // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
    // followed by the length, followed by the string
    llength = firstByte - 182;

    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }

    length = safeParseInt(input.slice(1, llength).toString("hex"), 16);

    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }

    data = input.slice(llength, length + llength);

    if (data.length < length) {
      throw new Error("invalid RLP: not enough bytes for string");
    }

    return {
      data: data,
      remainder: input.slice(length + llength)
    };
  } else if (firstByte <= 247) {
    // a list between  0-55 bytes long
    length = firstByte - 191;
    innerRemainder = input.slice(1, length);

    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }

    return {
      data: decoded,
      remainder: input.slice(length)
    };
  } else {
    // a list  over 55 bytes long
    llength = firstByte - 246;
    length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
    var totalLength = llength + length;

    if (totalLength > input.length) {
      throw new Error("invalid rlp: total length is larger than the data");
    }

    innerRemainder = input.slice(llength, totalLength);

    if (innerRemainder.length === 0) {
      throw new Error("invalid rlp, List has a invalid length");
    }

    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }

    return {
      data: decoded,
      remainder: input.slice(totalLength)
    };
  }
}
/** Check if a string is prefixed by 0x */


function isHexPrefixed(str) {
  return str.slice(0, 2) === "0x";
}
/** Removes 0x from a given String */


function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */


function intToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }

  var hex = integer.toString(16);
  return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */


function padToEven(a) {
  return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */


function intToBuffer(integer) {
  var hex = intToHex(integer);
  return Buffer.from(hex, "hex");
}
/** Transform anything into a Buffer */


function toBuffer(v) {
  if (!Buffer.isBuffer(v)) {
    if (typeof v === "string") {
      if (isHexPrefixed(v)) {
        return Buffer.from(padToEven(stripHexPrefix(v)), "hex");
      } else {
        return Buffer.from(v);
      }
    } else if (typeof v === "number" || typeof v === "bigint") {
      if (!v) {
        return Buffer.from([]);
      } else {
        return intToBuffer(v);
      }
    } else if (v === null || v === undefined) {
      return Buffer.from([]);
    } else if (v instanceof Uint8Array) {
      return Buffer.from(v);
    } else if (bn_js_1.default.isBN(v)) {
      // converts a BN to a Buffer
      return Buffer.from(v.toArray());
    } else {
      throw new Error("invalid type");
    }
  }

  return v;
} 
const __esModule = exports.__esModule;
const _getLength = exports.getLength,
      _decode2 = exports.decode,
      _encode = exports.encode;

export { __esModule, _decode2 as decode, exports as default, _encode as encode, _getLength as getLength };

//# sourceMappingURL=npm:rlp@2.2.7!cjs.map