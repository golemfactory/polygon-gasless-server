import _safeBuffer from '/npm:safe-buffer@5!cjs';

var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

var exports = {};
var Buffer = _safeBuffer.Buffer; // prototype class for hash functions

function Hash(blockSize, finalSize) {
  (this || _global)._block = Buffer.alloc(blockSize);
  (this || _global)._finalSize = finalSize;
  (this || _global)._blockSize = blockSize;
  (this || _global)._len = 0;
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === "string") {
    enc = enc || "utf8";
    data = Buffer.from(data, enc);
  }

  var block = (this || _global)._block;
  var blockSize = (this || _global)._blockSize;
  var length = data.length;
  var accum = (this || _global)._len;

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }

    accum += remainder;
    offset += remainder;

    if (accum % blockSize === 0) {
      this._update(block);
    }
  }

  (this || _global)._len += length;
  return this || _global;
};

Hash.prototype.digest = function (enc) {
  var rem = (this || _global)._len % (this || _global)._blockSize;
  (this || _global)._block[rem] = 128; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

  (this || _global)._block.fill(0, rem + 1);

  if (rem >= (this || _global)._finalSize) {
    this._update((this || _global)._block);

    (this || _global)._block.fill(0);
  }

  var bits = (this || _global)._len * 8; // uint32

  if (bits <= 4294967295) {
    (this || _global)._block.writeUInt32BE(bits, (this || _global)._blockSize - 4); // uint64

  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;

    (this || _global)._block.writeUInt32BE(highBits, (this || _global)._blockSize - 8);

    (this || _global)._block.writeUInt32BE(lowBits, (this || _global)._blockSize - 4);
  }

  this._update((this || _global)._block);

  var hash = this._hash();

  return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
  throw new Error("_update must be implemented by subclass");
};

exports = Hash;
var _hash = exports;

export { _hash as _ };

//# sourceMappingURL=c75f0f87.js.map